/*
  plt and plotr: SciVis-2023 Project 1
  Copyright (C)  2023 University of Chicago. All rights reserved.

  This is only for students and instructors in the 2023 CMSC 23710/33710
  ("SciVis") class, for use in that class. It is not licensed for open-source
  or any other kind of re-distribution. Do not allow this file to be copied
  or downloaded by anyone outside the 2023 SciVis class.
*/

#include "plt.h"
#include "pltPrivate.h"
#ifdef SCIVIS_GRADE
#  include "rplt.h"
#  include "pltGrade.h"
#endif
#include "pltTime.h"
#ifdef KEC // see top of kernel.c
KEC_DECL;
#endif

#define INFO "Plot (i.e. make an image of a graph of) a convolution result"
static char *infoLong = INFO
  ". The main work is done with pltPlot(); "
  "use this to debug your implementation. "
  "The output (\"-o\") filename should end with \".png\" in order to "
  "generate a PNG image that you can view with a normal image viewer. "
  "The given code (specifically nrrdSave) handles all the details of the "
  "PNG format for you. You just need to make sure pltPlot sets all the "
  "pixel values according to the specification.";

static int
plotMain(int argc, const char **argv, const char *me, hestParm *hparm) {
    airArray *mop = airMopNew();
    hestOpt *hopt = NULL;
    char *iname;
    hestOptAdd(&hopt, "i", "input", airTypeString, 1, 1, &iname, "",
               "filename of input data (that will be convolved and "
               "plotted here, e.g. generated by \"plotr psamp\"), "
               "OR, can leave empty (not using the \"i\" option at all) "
               "to do no convolution or plotting of any data (this is "
               "useful with \"-p\" for plotting exact polynomials)");
    pltKernel *kern;
    hestOptAdd(&hopt, "k", "kernel", airTypeOther, 1, 1, &kern, "tent",
               "kernel to use for convolution with input data", NULL, NULL,
               pltKernelHest);
    uint whichD;
    hestOptAdd(&hopt, "d", "whichD", airTypeUInt, 1, 1, &whichD, "0",
               "\"-d D\" requests that the Dth derivative (in world-space) "
               "of the convolution-based reconstruction be plotted, rather "
               "than the convolution itself");
    real *pc;
    uint pclen;
    hestOptAdd(&hopt, "p", "p0 p1", airTypeReal, 0, -1, &pc, "",
               "you can also include a plot of this "
               "polynomial, to compare with convolution result, by "
               "giving here the coefficients of polynomial, starting with "
               "degree 0, e.g. \"-p 1 2 3\" means 1 + 2x + 3x^2. By default, "
               "(not using this option), no polynomial is graphed.",
               &pclen);
    uint osize[2];
    hestOptAdd(&hopt, "s", "sx sy", airTypeUInt, 2, 2, osize, "640 480",
               "number of horizontal and vertical pixels in output image ");
    real xmm[2];
    hestOptAdd(&hopt, "xmm", "min max", airTypeReal, 2, 2, xmm, NULL,
               "range of world-space positions depicted by cell-centered "
               "samples along the horizontal axis of output image. The "
               "min X value is on the left side of the image; the max X "
               "is on the right side.");
    real ymm[2];
    hestOptAdd(&hopt, "ymm", "min max", airTypeReal, 2, 2, ymm, NULL,
               "range of values depicted by cell-centered "
               "samples along the vertical axis of output image. "
               "The (first) min Y value is on the *bottom* edge of the image; "
               "the (second) max Y is on the *top* edge.");
    real thickAxes;
    hestOptAdd(&hopt, "tha", "axis thickness", airTypeReal, 1, 1, &thickAxes, "5",
               "thickness, in pixels, of XY-axes drawn through world-space "
               "origin as well as thickness of \"outside\" indication "
               "(via \"-so true\"), OR, 0 for no such axes nor outside "
               "indication");
    real thickConvo;
    hestOptAdd(&hopt, "thc", "convo plot thickness", airTypeReal, 1, 1, &thickConvo, "9",
               "thickness, in pixels, of plot of convolution result");
    real thickPoly;
    hestOptAdd(&hopt, "thp", "polynomial plot thickness", airTypeReal, 1, 1, &thickPoly,
               "11", "thickness, in pixels, of plot of polynomial");
    int apcoth;
    hestOptAdd(&hopt, "apcoth", "bool", airTypeBool, 1, 1, &apcoth, "false",
               "if true, APproximate COnstant-THickness plots of both "
               "convolution and polynomial. ");
    real diamDot;
    hestOptAdd(&hopt, "dd", "dot diameter", airTypeReal, 1, 1, &diamDot, "0",
               "diameter, in pixels, of circular dots drawn to indicate the "
               "world-space positions and values of the \"-i\" input "
               "discrete data, OR, 0 for no such dots");
    real heightZC;
    hestOptAdd(&hopt, "hz", "height", airTypeReal, 1, 1, &heightZC, "0",
               "height, in pixels, of tick-marks on y=0 drawn where "
               "linear interpolation between successive data values cross "
               "the y=0 axis.  Thickess of tickmarks is the same as the axes "
               "(from \"-tha\"). OR, 0 for no such tickmarks");
    char *oname;
    hestOptAdd(&hopt, "o", "output", airTypeString, 1, 1, &oname, NULL,
               "output file; should end with \".png\"");
    hestParseOrDie(hopt, argc, argv, hparm, me, infoLong, AIR_TRUE, AIR_TRUE, AIR_TRUE);
    airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
    airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);

    Nrrd *nrgb = nrrdNew();
    airMopAdd(mop, nrgb, (airMopper)nrrdNuke, airMopAlways);
    if (nrrdAlloc_va(nrgb, nrrdTypeUChar, 3, (size_t)3, (size_t)osize[0],
                     (size_t)osize[1])) {
        ERROR(NRRD, "trouble allocating output image");
    }
    pltData *idata = NULL;
    if (strlen(iname)) {
        idata = pltDataNew();
        airMopAdd(mop, idata, (airMopper)pltDataNix, airMopAlways);
        if (pltDataLoad(idata, iname)) {
            ERROR(PLT, "trouble loading input data");
        }
    }
    // . . . . . . . . . . . . . . . . . useful code here
    pltRoundSet();
    TIME_START(stu);
    if (pltPlot(nrgb->data, osize[0], osize[1], xmm[0], xmm[1], ymm[0], ymm[1], whichD,
                idata, idata ? kern : NULL, pc, pclen, thickConvo, thickPoly, apcoth,
                thickAxes, diamDot, heightZC)) {
        ERROR(PLT, "trouble with input data or plotting it");
    }
    TIME_END(stutime, stu);
    pltRoundUnset();
    // ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' useful code here
#ifdef KEC
    KEC_PRINT;
#endif
    // record meta-data about image domain and its sampling
    nrgb->axis[1].min = (double)xmm[0];
    nrgb->axis[1].max = (double)xmm[1];
    nrgb->axis[1].center = nrrdCenterCell;
    nrgb->axis[2].min = (double)ymm[1];
    nrgb->axis[2].max = (double)ymm[0];
    nrgb->axis[2].center = nrrdCenterCell;
    nrgb->content = pltCommandLine(me, argv);
#ifndef SCIVIS_GRADE
    if (nrrdSave(oname, nrgb, NULL)) {
        ERROR(NRRD, "trouble saving output");
    }
    pltOutput(oname);
#else
    Nrrd *rnrgb = nrrdNew();
    airMopAdd(mop, rnrgb, (airMopper)nrrdNuke, airMopAlways);
    if (nrrdAlloc_va(rnrgb, nrrdTypeUChar, 3, (size_t)3, (size_t)osize[0],
                     (size_t)osize[1])) {
        ERROR(NRRD, "trouble allocating reference output image");
    }
    pltRoundSet();
    TIME_START(ref);
    if (ref_pltPlot(rnrgb->data, osize[0], osize[1], xmm[0], xmm[1], ymm[0], ymm[1],
                    whichD, idata, idata ? kern : NULL, pc, pclen, thickConvo, thickPoly,
                    apcoth, thickAxes, diamDot, heightZC)) {
        ERROR(PLT, "trouble with input data or reference plotting it");
    }
    TIME_END(reftime, ref);
    pltRoundUnset();
    pltGradeImage(oname, nrgb->content, nrgb->data, rnrgb->data, 1 /* isUChar */, 3,
                  osize[0], osize[1], stutime, reftime);
#endif

    airMopOkay(mop);
    return 0;
}

unrrduCmd plt_plotCmd = {"plot", INFO, plotMain, AIR_FALSE};

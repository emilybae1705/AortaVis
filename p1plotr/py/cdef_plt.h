// Look for "TODO"s that highlight which functions you have to finish

/* The pltCenter C enum represents the two different strategies of uniformly sampling an
   interval. pltCenter_ae is an airEnum around the same values. NOTE: with this or any
   other enum, do not ever use hard-coded constants 1 or 2 in your code because that
   would be illegible; use pltCenterNode or pltCenterCell instead. */
typedef enum {
    pltCenterUnknown = 0, // sample centering not known
    pltCenterNode,        // (1) node-centered samples
    pltCenterCell,        // (2) cell-centered samples
} pltCenter;

/* The pltMark C enum represents the different things ("marks") to be drawn in the image
   generated by pltPLot; each has its own RGB color. */
typedef enum {
    pltMarkUnknown = 0,  // mark unknown
    pltMarkBackground,   // (1) background behind all marks
    pltMarkAxes,         // (2) axes along Y=0 and X=0
    pltMarkPolynomial,   // (3) plot of an exact polynomial
    pltMarkOutsideOne,   // (4) where (on Y=0 axis) one data sample missing for convo
    pltMarkOutsideMore,  // (5) where (on Y=0 axis) > 1 data samples missing for convo
    pltMarkConvolution,  // (6) plot of the convolution result
    pltMarkDot,          // (7) dots showing underlying data samples
    pltMarkZeroCrossing, // (8) zero crossings (by lerp) between data samples
} pltMark;

/* misc.c: other miscellaneous things (nothing for you to implement). An airEnum (defined
   in teem/air.h) is a gadget that simplifies converting between integer C enum values
   and the strings (like "node" for pltCenterNode) that might represent those values
   on the command-line or in a GUI.  */
extern const airEnum *const pltCenter_ae;
extern const airEnum *const pltMark_ae;

/* The pltData struct stores len sampled data values in array vv[], and the meta-data
   about the sampling needed to unambiguously define the world-space locations of each
   sample: the interval [min,max] that was sampled (if min < max), and (center) whether
   the samples are node- or cell-centered. It is possible that min > max: "min" is
   technically the world-space end-point of the sampling interval closer to where vv[0]
   was sampled, and "max" is the end-point of the interval closer to where vv[len-1] was
   sampled. */
typedef struct {
    real *vv;         // data values
    uint len;         // length of array vv
    real min, max;    // values sampled in interval [min,max] (or [max,min])
    pltCenter center; // either pltCenterNode or pltCenterCell
} pltData;

/* data.c: functions for creating, destroying, writing, and reading the pltData
   (nothing for you to implement) */
extern pltData *pltDataNew(void);
extern pltData *pltDataNix(pltData *data);
extern int pltDataInit(pltData *data, uint len, real min, real max, pltCenter center);
extern int pltDataSave(const char *fname, const pltData *data, const char *content);
extern int pltDataLoad(pltData *data, const char *fname);

/* util.c: How to lerp, and to convert between index space and world space.
   TODO: finish implementing these three functions */
extern real pltLerp(real omin, real omax, real imin, real xx, real imax);
extern real pltItoW(const pltData *data, real indexPos);
extern real pltWtoI(const pltData *data, real worldPos);

/* poly.c: evaluating and sampling a polynomial.
   TODO: you will finish implementing these two functions */
extern real pltPolyEval(const real *pc, uint pclen, real xx);
extern int pltPolySample(pltData *data, uint len, real imin, real imax, pltCenter center,
                         const real *pc, uint pclen);

/* convo.c: evaluating convolution at one location or at array of locations.
   TODO: finish pltConvoEval */
extern int pltConvoEval(real *result, unsigned short *outside, real xx, uint whichD,
                        const pltData *data, const pltKernel *kern);
extern int pltConvoSample(pltData *odata, uint olen, real omin, real omax,
                          pltCenter center, uint whichD, const pltData *din,
                          const pltKernel *kern);

/* pplot.c: for doing the final graph drawing as a raster image.
   TODO: finish pltPlot */
extern int pltPlot(unsigned char *const rgb, uint xsize, uint ysize, real xmin,
                   real xmax, real ymin, real ymax, uint whichD, const pltData *idata,
                   const pltKernel *kern, const real *pc, uint pclen,
                   real thicknessConvo, real thicknessPoly, int apcoth,
                   real thicknessAxes, real dotRadius, real heightZC);

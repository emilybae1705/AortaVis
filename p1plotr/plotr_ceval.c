/*
  plt and plotr: SciVis-2023 Project 1
  Copyright (C)  2023 University of Chicago. All rights reserved.

  This is only for students and instructors in the 2023 CMSC 23710/33710
  ("SciVis") class, for use in that class. It is not licensed for open-source
  or any other kind of re-distribution. Do not allow this file to be copied
  or downloaded by anyone outside the 2023 SciVis class.
*/

#include "plt.h"
#include "pltPrivate.h"
#ifdef SCIVIS_GRADE
#  include "rplt.h"
#  include "pltGrade.h"
#endif
#ifdef KEC // see top of kernel.c
KEC_DECL;
#endif

#define INFO "Evaluate a convolution at a single location"
static char *infoLong = (INFO
                         ". The main work is done with pltConvoEval(); use this command "
                         "to debug your implementation.");

static int
cevalMain(int argc, const char **argv, const char *me, hestParm *hparm) {
    airArray *mop = airMopNew();
    hestOpt *hopt = NULL;
    char *fname;
    hestOptAdd(&hopt, "i", "input", airTypeString, 1, 1, &fname, NULL,
               "filename of input data (e.g. generated by \"plotr psamp\")");
    pltKernel *kern;
    hestOptAdd(&hopt, "k", "kernel", airTypeOther, 1, 1, &kern, NULL,
               "kernel to use for convolution", NULL, NULL, pltKernelHest);
    real xx;
    hestOptAdd(&hopt, "x", "position", airTypeReal, 1, 1, &xx, NULL,
               "the single *world-space* position (within segment of world "
               "space sampled by the \"-i\" input) at which to evaluate the "
               "convolution of data and kernel");
    uint whichD;
    hestOptAdd(&hopt, "d", "whichD", airTypeUInt, 1, 1, &whichD, "0",
               "\"-d D\" requests that the Dth derivative, "
               "**in world-space**, of the convolution be sampled, "
               "rather than the convolution itself");
    hestParseOrDie(hopt, argc, argv, hparm, me, infoLong, AIR_TRUE, AIR_TRUE, AIR_TRUE);
    airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
    airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);

    pltData *data = pltDataNew();
    airMopAdd(mop, data, (airMopper)pltDataNix, airMopAlways);
    if (pltDataLoad(data, fname)) {
        ERROR(PLT, "trouble with input");
    }

    // . . . . . . . . . . . . . . . . . useful code here
    // initialize outside to bogus value; should get over-written
    unsigned short outside = (unsigned short)(-1);
    real result = pltNan(0);
    pltRoundSet();
    if (pltConvoEval(&result, &outside, xx, whichD, data, kern)) {
        ERROR(PLT, "trouble with convolution");
    }
    pltRoundUnset();
    // ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' useful code here
#ifdef KEC
    KEC_PRINT;
#endif

    const pltKernel *kk = kern;
    for (uint ii = 0; ii < whichD; ii++) {
        kk = kk->deriv;
    }
#ifndef SCIVIS_GRADE
    if (outside) {
        if ((unsigned short)(-1) == outside) {
            printf("!! pltConvoEval did not set outside; can't tell if "
                   "convolution was successful\n");
        } else {
            printf("No result: %hu samples outside [0,%u]\n", outside, data->len - 1);
        }
    } else {
        pltPrintf("%g = pltConvoEval(%s, %s, %g); outside=0\n", result, fname, kk->name,
                  xx);
    }
#else // yes grading
    unsigned short routside = (unsigned short)(-1);
    real rresult = pltNan(0);
    pltRoundSet();
    if (ref_pltConvoEval(&rresult, &routside, xx, whichD, data, kern)) {
        ERROR(PLT, "trouble with reference convolution");
    }
    pltRoundUnset();
    pltPrintf("%s: calling pltConvoEval(%s, %s, %g)\n", me, fname, kk->name, xx);
    /* both result and rresult were initialized to pltNan(0), so
       either non-zero outsides should match, or outsides are zero,
       and results should match */
    if (outside || routside) {
        pltPrintf("%s: outside: %u you vs %u ref\n", me, outside, routside);
        pltGradeInt(outside, routside, "outside");
    } else {
        // student and ref agree that 0==outside
        pltPrintf("%s: result: %g you vs %g ref (outside=0)\n", me, result, rresult);
        pltGradeReal(result, rresult, "result");
    }
#endif

    airMopOkay(mop);
    return 0;
}

unrrduCmd plt_cevalCmd = {"ceval", INFO, cevalMain, AIR_FALSE};

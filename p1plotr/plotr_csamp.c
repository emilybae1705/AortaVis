/*
  plt and plotr: SciVis-2023 Project 1
  Copyright (C)  2023 University of Chicago. All rights reserved.

  This is only for students and instructors in the 2023 CMSC 23710/33710
  ("SciVis") class, for use in that class. It is not licensed for open-source
  or any other kind of re-distribution. Do not allow this file to be copied
  or downloaded by anyone outside the 2023 SciVis class.
*/

#include "plt.h"
#include "pltPrivate.h"
#ifdef SCIVIS_GRADE
#  include "rplt.h"
#  include "pltGrade.h"
#endif
#include "pltTime.h"

#define INFO "Repeatedly evaluate (sample) a convolution over an interval"
static char *infoLong = INFO
  ". The main work is done with pltConvoSample() in convo.c; "
  "this may also help debug your implementation of pltConvoEval(). "
  "If the given output (\"-o\") filename ends with "
  "\".txt\", the values are saved, one per line, to a plain text file. "
  "The \"#\" lines at the start of the text file document the meta-data "
  "required to locate the samples in some world-space interval. If the "
  "output filename ends with anything else (including \".nrrd\"), "
  "the NRRD file format is used.";

static int
csampMain(int argc, const char **argv, const char *me, hestParm *hparm) {
    airArray *mop = airMopNew();
    hestOpt *hopt = NULL;
    char *iname;
    hestOptAdd(&hopt, "i", "input", airTypeString, 1, 1, &iname, NULL,
               "filename of input data (e.g. generated by \"plotr psamp\")");
    pltKernel *kern;
    hestOptAdd(&hopt, "k", "kernel", airTypeOther, 1, 1, &kern, NULL,
               "kernel to use for convolution", NULL, NULL, pltKernelHest);
    float mm[2];
    hestOptAdd(&hopt, "mm", "min max", airTypeFloat, 2, 2, mm, NULL,
               "min and max bounds over which to do sampling of polynomial");
    uint olen;
    hestOptAdd(&hopt, "n", "#samples", airTypeUInt, 1, 1, &olen, NULL,
               "number of samples to take over -mm interval");
    pltCenter center;
    hestOptAdd(&hopt, "c", "center", airTypeEnum, 1, 1, &center, "cell",
               "whether to sample -mm interval with cell-centered "
               "(\"-c cell\") or node-centered (\"-c node\") samples",
               NULL, pltCenter_ae);
    uint whichD;
    hestOptAdd(&hopt, "d", "whichD", airTypeUInt, 1, 1, &whichD, "0",
               "\"-d D\" requests that the Dth derivative, "
               "**in world-space**, of the convolution be sampled, rather "
               "than the convolution itself");
    char *oname;
    hestOptAdd(&hopt, "o", "output", airTypeString, 1, 1, &oname, NULL,
               "output file, ending either with \".txt\" or \".nrrd\"");
    hestParseOrDie(hopt, argc, argv, hparm, me, infoLong, AIR_TRUE, AIR_TRUE, AIR_TRUE);
    airMopAdd(mop, hopt, (airMopper)hestOptFree, airMopAlways);
    airMopAdd(mop, hopt, (airMopper)hestParseFree, airMopAlways);

    // . . . . . . . . . . . . . . . . . useful code here
    pltData *idata = pltDataNew();
    airMopAdd(mop, idata, (airMopper)pltDataNix, airMopAlways);
    pltData *odata = pltDataNew();
    airMopAdd(mop, odata, (airMopper)pltDataNix, airMopAlways);
    char *cmdl = pltCommandLine(me, argv);
    airMopAdd(mop, cmdl, airFree, airMopAlways);
    if (pltDataLoad(idata, iname)) {
        ERROR(PLT, "trouble loading data");
    }
    int E = 0;
    pltRoundSet();
    TIME_START(stu);
    if (!E) E |= pltConvoSample(odata, olen, mm[0], mm[1], center, whichD, idata, kern);
    TIME_END(stutime, stu);
    pltRoundUnset();
    if (E) {
        ERROR(PLT, "trouble computing output");
    }
#ifndef SCIVIS_GRADE
    if (pltDataSave(oname, odata, cmdl)) {
        ERROR(PLT, "trouble saving output");
    }
    pltOutput(oname);
    // ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' useful code here
#else
    pltData *rodata = pltDataNew();
    airMopAdd(mop, rodata, (airMopper)pltDataNix, airMopAlways);
    pltRoundSet();
    TIME_START(ref);
    if (!E)
        E |= ref_pltConvoSample(rodata, olen, mm[0], mm[1], center, whichD, idata, kern);
    TIME_END(reftime, ref);
    pltRoundUnset();
    if (E) {
        ERROR(PLT, "trouble computing reference output");
    }
    /* pltConvoSample is given completely, and so the meta-data
       should be the same; we're using it here as a way of calling
       convolution repeatedly */
    pltGradeItem *itm = pltGradeItemZip(odata->vv, rodata->vv, olen);
    airMopAdd(mop, itm, airFree, airMopAlways);
    pltGradeTuple(itm, olen, stutime, reftime);
#endif

    airMopOkay(mop);
    return 0;
}

unrrduCmd plt_csampCmd = {"csamp", INFO, csampMain, AIR_FALSE};
